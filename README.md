# DxfIO

This is a gem for read and write DXF files and for processing of simple actions over dxf entities.
Reader part of the gem based on [ruby-dxf-reader](https://github.com/jimfoltz/ruby-dxf-reader).
Gem supported DXF files generated by AutoCAD 2008 ([dxf-specification](http://images.autodesk.com/adsk/files/acad_dxf0.pdf)).

[![Gem Version](https://badge.fury.io/rb/dxf_io.png)](http://badge.fury.io/rb/dxf_io)

## Installation

Add this line to your application's Gemfile:

```ruby
gem 'dxf_io'
```

And then execute:

    $ bundle

Or install it yourself as:

    $ gem install dxf_io

## Usage

Gem consists from __Reader__, __Writer__, __Wrapper__ and support classes.

### Reader

Reader require a path to DXF file and return a hash with dxf-objects.

Reader can be initialized as follows:

```ruby
reader_instance = DxfIO::Reader.new(path: '/path/to/your/file.dxf')
```

Additionally you can use `open` method:

```ruby
DxfIO::Reader.open('/path/to/your/file.dxf') do |dxf_reader_instance|
  # ...
end
```

`open` receive same options as `new`.

Available options of __Reader__:

* path - path to DXF-file (required)
* encoding - encoding of input file (`'Windows-1251'` by default)

As alternative you may pass single string as input parameter:

```ruby
reader_instance = DxfIO::Reader.new('/path/to/your/file.dxf')
```

To obtain full hash with DXF content eval

```ruby
dxf_content = reader_instance.run
```

or

```ruby
dxf_content = reader_instance.to_h
```

Format of resulted hash:

    {
                 "HEADER" => {...}, 
                "CLASSES" => [...],
                 "TABLES" => [...],
                 "BLOCKS" => [...],
               "ENTITIES" => [...],
                "OBJECTS" => [...],
        "THUMBNAILIMAGES" => [...]
    }

If you need certain part of DXF you may execute one of the following functions

* header
* classes
* tables
* blocks
* entities
* objects
* thumbnailimages

Format of __header__ section is

    {
        $PLIMCHECK" => {
            70 => 0
        },
        "$PEXTMIN" => {
            10 => 1.0e+20,
            20 => 1.0e+20,
            30 => 1.0e+20
        },
        ...
    }

Other section has different format:

    [
        [
            {   0 => "CLASS" },
            {   1 => "VISUALSTYLE" },
            {   2 => "AcDbVisualStyle" },
            {   3 => "ObjectDBX Classes" },
            {  90 => 4095 },
            { 280 => 0 },
            { 281 => 0 }
        ],
        [...]
    ]

Sequence of groups and values is same as in DXF file.

#### Notes

* Reader caches result of parse DXF file. If you want to update a cache call `reader_instance.rerun`.
* Reader automatically cast integer and float values to proper Ruby classes.

### Writer

__Writer__ receive a dxf-hash in format from __Reader__ and construct a DXF-file.

__Writer__ can be initialized as follow

```ruby
writer_instance = DxfIO::Writer.new(dxf_hash: dxf_content, path: '/path/to/new/file.dxf')
```

To process write execute `writer_instance.run`.

Alternative way to use __Writer__:

```ruby
writer_instance = DxfIO::Writer.open('/path/to/new/file.dxf') do |dxf_writer_instance|
  # ...
  dxf_writer_instance.write_hash dxf_hash
end
```

`open` receive same options as `new`.

Available options of __Writer__:

* dxf_hash - hash with DXF-file in format of __Reader__ (required in `new` or in `run`/`write_hash` methods)
* path - path to new DXF-file (required)
* encoding - encoding of output file (`'Windows-1251'` by default)
* delimiter - delimiter in DXF-file (`"\r\n"` by default)
* strategy - strategy of _Writer_ (`:memory` by default)

#### Write strategy

__Writter__ support two strategy:

1. `:disk` - a lot of small write operation for each group, section etc
2. `:memory` - prepare full file content in memory and write by a single operation (default behaviour)

### Wrapper

__Wrapper__ provide several tools for work with dxf-entities.

__Wrapper__ can be initialized as follow

```ruby
wrapper_instance = DxfIO::Wrapper.new(dxf_hash: dxf_content)
```

It has functions for fetch any groups except header:

* classes
* tables
* blocks
* entities
* objects
* thumbnailimages

Any of these functions return array with __Entity__ which is `DxfIO::Entity::Other`.

Each __Entity__ has follows methods

* to_a - same as in __Reader__ format
* to_h - hash with group code on keys and array with group values on values
* type - value of zero group (for example "LINE")
* points - array of __Points__ which is `DxfIO::Entity::Support::Point`
* xs - array of X-coordinates
* ys - array of Y-coordinates
* move_to! - receive __Point__ and move all points of current __Entity__

### Support

#### Point

This is a simple class for storage 2D points. It provide follows methods:

* x - access to X-coordinate
* y - access to Y-coordinate
* start? - is this start-point of primitive (codes 10 and 20 from [dxf-specification](http://images.autodesk.com/adsk/files/acad_dxf0.pdf))
* end? - is this end-point of primitive (codes 11 and 21 from [dxf-specification](http://images.autodesk.com/adsk/files/acad_dxf0.pdf))
* `==`
* binary `+`, `-`, `*`, `/`
* unary `-`
* `rotate_90`, `rotate_180` (supposed what point is a vector from zero)

## Development

After checking out the repo, run `bin/setup` to install dependencies. Then, run `bin/console` for an interactive prompt that will allow you to experiment.

To install this gem onto your local machine, run `bundle exec rake install`.

## Contributing

1. Fork it ( https://github.com/Loriowar/dxf_io/fork )
2. Create your feature branch (`git checkout -b my-new-feature`)
3. Commit your changes (`git commit -am 'Add some feature'`)
4. Push to the branch (`git push origin my-new-feature`)
5. Create a new Pull Request
